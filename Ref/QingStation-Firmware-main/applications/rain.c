/*
 * Copyright (c) 2020-2021, Jianjia Ma
 * majianjia@live.com
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author           Notes
 * 2021-02-07     Jianjia Ma       the first version
 */

#include <rtthread.h>
#include <rtdevice.h>
#include <board.h>
#include "configuration.h"
#include "data_pool.h"
#include <stdlib.h>
#include "string.h"
#include "math.h"
#include "drv_anemometer.h" // for analog power supply
#include "stm32l4xx_ll_bus.h"
#include "stm32l4xx_ll_rcc.h"
#include "stm32l4xx_ll_system.h"
#include "stm32l4xx_ll_utils.h"
#include "stm32l4xx_ll_cortex.h"
#include "stm32l4xx_ll_gpio.h"
#include "stm32l4xx_ll_exti.h"
#include "stm32l4xx_ll_adc.h"
#include "stm32l4xx_ll_dma.h"

#define DBG_TAG "rain"
#define DBG_LVL DBG_LOG
#include <rtdbg.h>

#define IR_LED_PIN  GET_PIN(A, 4)

typedef struct data_buffer {
    int16_t *buf;
    int32_t idx;
    int32_t size;
    bool is_full;
} data_buffer_t;
static data_buffer_t rain_data;

// generated by cubemx in cubemx/src/main.c
extern ADC_HandleTypeDef hadc1;
extern DMA_HandleTypeDef hdma_adc1;
//extern ADC_ChannelConfTypeDef ADC_ChanConf;

//ADC init
static void ADC_Init(void)
{
    int rslt = HAL_OK;
  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 2, 0); //we dont need it.
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);

  do{
      rt_thread_delay(100);


      /* USER CODE BEGIN ADC1_Init 0 */

      /* USER CODE END ADC1_Init 0 */

      ADC_MultiModeTypeDef multimode = {0};
      ADC_ChannelConfTypeDef sConfig = {0};

      /* USER CODE BEGIN ADC1_Init 1 */

      /* USER CODE END ADC1_Init 1 */
      /** Common config
      */
      hadc1.Instance = ADC1;
      hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
      hadc1.Init.Resolution = ADC_RESOLUTION_12B;
      hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
      hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
      hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
      hadc1.Init.LowPowerAutoWait = DISABLE;
      hadc1.Init.ContinuousConvMode = ENABLE;
      hadc1.Init.NbrOfConversion = 4;
      hadc1.Init.DiscontinuousConvMode = DISABLE;
      hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
      hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
      hadc1.Init.DMAContinuousRequests = ENABLE;
      hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
      hadc1.Init.OversamplingMode = DISABLE;
      rslt = HAL_ADC_Init(&hadc1);
      if (rslt != HAL_OK)
      {
          HAL_ADC_DeInit(&hadc1);
          continue;
      }

      multimode.Mode = ADC_MODE_INDEPENDENT;
      rslt = HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode);
      if (rslt != HAL_OK)
         continue;

      sConfig.Channel = ADC_CHANNEL_4;
      sConfig.Rank = ADC_REGULAR_RANK_1;
      sConfig.SamplingTime = ADC_SAMPLETIME_640CYCLES_5;
      sConfig.SingleDiff = ADC_SINGLE_ENDED;
      sConfig.OffsetNumber = ADC_OFFSET_NONE;
      sConfig.Offset = 0;
      rslt = HAL_ADC_ConfigChannel(&hadc1, &sConfig);
      if (rslt != HAL_OK)
         continue;

      sConfig.Channel = ADC_CHANNEL_6;
      sConfig.Rank = ADC_REGULAR_RANK_2;
      rslt = HAL_ADC_ConfigChannel(&hadc1, &sConfig);
      if (rslt != HAL_OK)
         continue;

      sConfig.Channel = ADC_CHANNEL_VREFINT;
      sConfig.Rank = ADC_REGULAR_RANK_3;
      rslt = HAL_ADC_ConfigChannel(&hadc1, &sConfig);
      if (rslt != HAL_OK)
          continue;

      sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
      sConfig.Rank = ADC_REGULAR_RANK_4;
      rslt = HAL_ADC_ConfigChannel(&hadc1, &sConfig);
  } while(rslt !=  HAL_OK); // sometimes this fail.
}

static void MX_ADC1_Init(void)
{
    do{
        rt_thread_delay(100);
        //hadc1.Instance = ADC1;
        //HAL_ADC_DeInit(&hadc1); // never do that. deinit before init reset the rcc counter, fail init.

        hadc1.Instance = ADC1;
        hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
        hadc1.Init.Resolution = ADC_RESOLUTION_12B;
        hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
        hadc1.Init.ScanConvMode = ENABLE;
        hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
        hadc1.Init.LowPowerAutoWait = DISABLE;
        hadc1.Init.ContinuousConvMode = DISABLE;
        hadc1.Init.NbrOfConversion = 1;
        hadc1.Init.DiscontinuousConvMode = DISABLE;
        hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
        hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
        hadc1.Init.DMAContinuousRequests = DISABLE;
        hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
        hadc1.Init.OversamplingMode = DISABLE;
    } while( HAL_ADC_Init(&hadc1) != HAL_OK); // sometimes this fail.
}


// no interrupt, circular mode.
void dma_ll_init(uint16_t *buf, int buf_size)
{
    /*## Configuration of NVIC #################################################*/
    /* Configure NVIC to enable DMA interruptions */
    NVIC_SetPriority(DMA1_Channel1_IRQn, 1); /* DMA IRQ lower priority than ADC IRQ */
    //NVIC_EnableIRQ(DMA1_Channel1_IRQn);
    NVIC_DisableIRQ(DMA1_Channel1_IRQn); // not needed

    /*## Configuration of DMA ##################################################*/
    /* Enable the peripheral clock of DMA */
    LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);

    /* Configure the DMA transfer */
    /*  - DMA transfer in circular mode to match with ADC configuration:        */
    /*    DMA unlimited requests.                                               */
    /*  - DMA transfer from ADC without address increment.                      */
    /*  - DMA transfer to memory with address increment.                        */
    /*  - DMA transfer from ADC by half-word to match with ADC configuration:   */
    /*    ADC resolution 12 bits.                                               */
    /*  - DMA transfer to memory by half-word to match with ADC conversion data */
    /*    buffer variable type: half-word.                                      */
    LL_DMA_ConfigTransfer(DMA1,
                       LL_DMA_CHANNEL_1,
                       LL_DMA_DIRECTION_PERIPH_TO_MEMORY |
                       LL_DMA_MODE_CIRCULAR              |
                       LL_DMA_PERIPH_NOINCREMENT         |
                       LL_DMA_MEMORY_INCREMENT           |
                       LL_DMA_PDATAALIGN_HALFWORD        |
                       LL_DMA_MDATAALIGN_HALFWORD        |
                       LL_DMA_PRIORITY_LOW               );

    /* Select ADC as DMA transfer request */
    LL_DMA_SetPeriphRequest(DMA1,  LL_DMA_CHANNEL_1, LL_DMA_REQUEST_0);

    /* Set DMA transfer addresses of source and destination */
    LL_DMA_ConfigAddresses(DMA1, LL_DMA_CHANNEL_1,
                        LL_ADC_DMA_GetRegAddr(ADC1, LL_ADC_DMA_REG_REGULAR_DATA),
                        (uint32_t)buf,
                        LL_DMA_DIRECTION_PERIPH_TO_MEMORY);

    /* Set DMA transfer size */
    LL_DMA_SetDataLength(DMA1, LL_DMA_CHANNEL_1, buf_size);

//    /* Enable DMA transfer interruption: transfer complete */
//    LL_DMA_EnableIT_TC(DMA1, LL_DMA_CHANNEL_1);
//
//    /* Enable DMA transfer interruption: half transfer */
//    LL_DMA_EnableIT_HT(DMA1, LL_DMA_CHANNEL_1);
//
//    /* Enable DMA transfer interruption: transfer error */
//    LL_DMA_EnableIT_TE(DMA1, LL_DMA_CHANNEL_1);

    /*## Activation of DMA #####################################################*/
    /* Enable the DMA transfer */
    LL_DMA_EnableChannel(DMA1, LL_DMA_CHANNEL_1);
}

// no interrup version
void adc_ll_init()
{
      /*## Configuration of GPIO used by ADC channels ############################*/
      /* Enable GPIO Clock */
      LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_GPIOA);

      /* Configure GPIO in analog mode to be used as ADC input */
      LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_1, LL_GPIO_MODE_ANALOG);
      LL_GPIO_EnablePinAnalogControl(GPIOA, LL_GPIO_PIN_1);

      /* Configure GPIO in analog mode to be used as ADC input */
      LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_3, LL_GPIO_MODE_ANALOG);
      LL_GPIO_EnablePinAnalogControl(GPIOC, LL_GPIO_PIN_3);

      /*## Configuration of NVIC #################################################*/
      /* Configure NVIC to enable ADC1 interruptions */
//      NVIC_SetPriority(ADC1_2_IRQn, 0); /* ADC IRQ greater priority than DMA IRQ */
//      NVIC_EnableIRQ(ADC1_2_IRQn);

      /*## Configuration of ADC ##################################################*/

      /*## Configuration of ADC hierarchical scope: common to several ADC ########*/

      /* Enable ADC clock (core clock) */
      LL_AHB2_GRP1_EnableClock(LL_AHB2_GRP1_PERIPH_ADC);

      /* Note: Hardware constraint (refer to description of the functions         */
      /*       below):                                                            */
      /*       On this STM32 serie, setting of these features is conditioned to   */
      /*       ADC state:                                                         */
      /*       All ADC instances of the ADC common group must be disabled.        */
      /* Note: In this example, all these checks are not necessary but are        */
      /*       implemented anyway to show the best practice usages                */
      /*       corresponding to reference manual procedure.                       */
      /*       Software can be optimized by removing some of these checks, if     */
      /*       they are not relevant considering previous settings and actions    */
      /*       in user application.                                               */
      if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE() == 0)
      {
        /* Note: Call of the functions below are commented because they are       */
        /*       useless in this example:                                         */
        /*       setting corresponding to default configuration from reset state. */

        /* Set ADC clock (conversion clock) common to several ADC instances */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_CLOCK_ASYNC_DIV1); // align with ADC2 setting. Async = PLL. Sync = sysclock

        /* Set ADC measurement path to internal channels */
        // LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_PATH_INTERNAL_NONE);
        LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(ADC1), (LL_ADC_PATH_INTERNAL_VREFINT | LL_ADC_PATH_INTERNAL_TEMPSENSOR));


      /*## Configuration of ADC hierarchical scope: multimode ####################*/

        /* Set ADC multimode configuration */
        // LL_ADC_SetMultimode(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_MULTI_INDEPENDENT);

        /* Set ADC multimode DMA transfer */
        // LL_ADC_SetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_MULTI_REG_DMA_EACH_ADC);

        /* Set ADC multimode: delay between 2 sampling phases */
        // LL_ADC_SetMultiTwoSamplingDelay(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_MULTI_TWOSMP_DELAY_1CYCLE);

      }


      /*## Configuration of ADC hierarchical scope: ADC instance #################*/

      /* Note: Hardware constraint (refer to description of the functions         */
      /*       below):                                                            */
      /*       On this STM32 serie, setting of these features is conditioned to   */
      /*       ADC state:                                                         */
      /*       ADC must be disabled.                                              */
      if (LL_ADC_IsEnabled(ADC1) == 0)
      {
        /* Set ADC data resolution */
        LL_ADC_SetResolution(ADC1, LL_ADC_RESOLUTION_12B);

        /* Set ADC conversion data alignment */
        LL_ADC_SetResolution(ADC1, LL_ADC_DATA_ALIGN_RIGHT);

        /* Set ADC low power mode */
        LL_ADC_SetLowPowerMode(ADC1, LL_ADC_LP_MODE_NONE);

        /* Set ADC selected offset number: channel and offset level */
        //LL_ADC_SetOffset(ADC1, LL_ADC_OFFSET_1, LL_ADC_CHANNEL_9, 0x000); // default
      }


      /*## Configuration of ADC hierarchical scope: ADC group regular ############*/

      /* Note: Hardware constraint (refer to description of the functions         */
      /*       below):                                                            */
      /*       On this STM32 serie, setting of these features is conditioned to   */
      /*       ADC state:                                                         */
      /*       ADC must be disabled or enabled without conversion on going        */
      /*       on group regular.                                                  */
      if ((LL_ADC_IsEnabled(ADC1) == 0)               ||
          (LL_ADC_REG_IsConversionOngoing(ADC1) == 0)   )
      {
        /* Set ADC group regular trigger source */
        LL_ADC_REG_SetTriggerSource(ADC1, LL_ADC_REG_TRIG_SOFTWARE);


        /* Set ADC group regular continuous mode */
        LL_ADC_REG_SetContinuousMode(ADC1, LL_ADC_REG_CONV_CONTINUOUS);

        /* Set ADC group regular conversion data transfer */
        LL_ADC_REG_SetDMATransfer(ADC1, LL_ADC_REG_DMA_TRANSFER_UNLIMITED); // unlimited for circular mode

        /* Set ADC group regular overrun behavior */
        LL_ADC_REG_SetOverrun(ADC1, LL_ADC_REG_OVR_DATA_OVERWRITTEN);

        /* Set ADC group regular sequencer */
        /* Note: On this STM32 serie, ADC group regular sequencer is              */
        /*       fully configurable: sequencer length and each rank               */
        /*       affectation to a channel are configurable.                       */
        /*       Refer to description of function                                 */
        /*       "LL_ADC_REG_SetSequencerLength()".                               */

        /* Set ADC group regular sequencer length and scan direction */
        LL_ADC_REG_SetSequencerLength(ADC1, LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS);

        /* Set ADC group regular sequencer discontinuous mode */
        LL_ADC_REG_SetSequencerDiscont(ADC1, LL_ADC_REG_SEQ_DISCONT_DISABLE);

        /* Set ADC group regular sequence: channel on the selected sequence rank. */
        LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_4);
        LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_2, LL_ADC_CHANNEL_6);
        LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_3, LL_ADC_CHANNEL_VREFINT);
        LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_4, LL_ADC_CHANNEL_TEMPSENSOR);

        LL_ADC_SetChannelSingleDiff(ADC1, LL_ADC_CHANNEL_4, LL_ADC_SINGLE_ENDED);
        LL_ADC_SetChannelSingleDiff(ADC1, LL_ADC_CHANNEL_6, LL_ADC_SINGLE_ENDED);
      }

      /*## Configuration of ADC hierarchical scope: channels #####################*/

      /* Note: Hardware constraint (refer to description of the functions         */
      /*       below):                                                            */
      /*       On this STM32 serie, setting of these features is conditioned to   */
      /*       ADC state:                                                         */
      /*       ADC must be disabled or enabled without conversion on going        */
      /*       on either groups regular or injected.                              */
      if ((LL_ADC_IsEnabled(ADC1) == 0)                    ||
          ((LL_ADC_REG_IsConversionOngoing(ADC1) == 0) &&
           (LL_ADC_INJ_IsConversionOngoing(ADC1) == 0)   )   )
      {
        /* Set ADC channels sampling time */
        /* Note: Considering interruption occurring after each number of          */
        /*       "ADC_CONVERTED_DATA_BUFFER_SIZE" ADC conversions                 */
        /*       (IT from DMA transfer complete),                                 */
        /*       select sampling time and ADC clock with sufficient               */
        /*       duration to not create an overhead situation in IRQHandler.      */
        LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_4, LL_ADC_SAMPLINGTIME_640CYCLES_5); // clock=25M / (650*4) ~= 10kHz
        LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_6, LL_ADC_SAMPLINGTIME_640CYCLES_5);
        LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_VREFINT, LL_ADC_SAMPLINGTIME_640CYCLES_5);
        LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_TEMPSENSOR, LL_ADC_SAMPLINGTIME_640CYCLES_5);
      }

      /*## Configuration of ADC interruptions ####################################*/

      //disable all interrupt
      ADC1->IER = 0;

      /* Enable interruption ADC group regular overrun */
      //LL_ADC_EnableIT_OVR(ADC1);


      /* Note: in this example, ADC group regular end of conversions              */
      /*       (number of ADC conversions defined by DMA buffer size)             */
      /*       are notified by DMA transfer interruptions).                       */
}

void adc_ll_start(void)
{
  __IO uint32_t wait_loop_index = 0;
  /*## Operation on ADC hierarchical scope: ADC instance #####################*/

  /* Note: Hardware constraint (refer to description of the functions         */
  /*       below):                                                            */
  /*       On this STM32 serie, setting of these features is conditioned to   */
  /*       ADC state:                                                         */
  /*       ADC must be disabled.                                              */
  /* Note: In this example, all these checks are not necessary but are        */
  /*       implemented anyway to show the best practice usages                */
  /*       corresponding to reference manual procedure.                       */
  /*       Software can be optimized by removing some of these checks, if     */
  /*       they are not relevant considering previous settings and actions    */
  /*       in user application.                                               */
  if (LL_ADC_IsEnabled(ADC1) == 0)
  {
    /* Disable ADC deep power down (enabled by default after reset state) */
    LL_ADC_DisableDeepPowerDown(ADC1);

    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(ADC1);
    rt_thread_delay(1); // this is needed
    /* Run ADC self calibration */
    LL_ADC_StartCalibration(ADC1, LL_ADC_SINGLE_ENDED);
    while (LL_ADC_IsCalibrationOnGoing(ADC1) != 0);
    rt_thread_delay(1); // this is needed

    /* Enable ADC */
    LL_ADC_Enable(ADC1);

    while (LL_ADC_IsActiveFlag_ADRDY(ADC1) == 0);

    /* Note: ADC flag ADRDY is not cleared here to be able to check ADC       */
    /*       status afterwards.                                               */
    /*       This flag should be cleared at ADC Deactivation, before a new    */
    /*       ADC activation, using function "LL_ADC_ClearFlag_ADRDY()".       */
  }

  /*## Operation on ADC hierarchical scope: ADC group regular ################*/
  /* Note: No operation on ADC group regular performed here.                  */
  /*       ADC group regular conversions to be performed after this function  */
  /*       using function:                                                    */
  LL_ADC_REG_StartConversion(ADC1);

  /*## Operation on ADC hierarchical scope: ADC group injected ###############*/
  /* Note: No operation on ADC group injected performed here.                 */
  /*       ADC group injected conversions to be performed after this function */
  /*       using function:                                                    */
  /*       "LL_ADC_INJ_StartConversion();"                                    */

}


//int get_adc_value(uint32_t channel)
//{
//    int temp;
//    ADC_ChanConf.Channel =  channel;
//    ADC_ChanConf.SamplingTime = ADC_SAMPLETIME_24CYCLES_5;
//    ADC_ChanConf.OffsetNumber = ADC_OFFSET_NONE;
//    ADC_ChanConf.SingleDiff = LL_ADC_SINGLE_ENDED;
//    HAL_ADC_ConfigChannel(&hadc1, &ADC_ChanConf);
//
//    HAL_ADC_Start(&hadc1);
//    HAL_ADC_PollForConversion(&hadc1, 100);
//    temp = HAL_ADC_GetValue(&hadc1);
//    return temp;
//}


//int measure_rain()
//{
//    uint16_t adc;
//    analog_power_request(true);
//    rt_pin_write(IR_LED_PIN, GPIO_PIN_SET);
//    rt_thread_mdelay(5);                // minimum 3 to be stable
//    adc = get_adc_value(ADC_CHANNEL_6);
//    rt_pin_write(IR_LED_PIN, GPIO_PIN_RESET);
//    analog_power_request(false);
//    return adc;
//}
//
//
//int measure_sys_voltage()
//{
//    return get_adc_value(ADC_CHANNEL_4);
//}
//
//float measure_vdda_voltage(float calib)
//{
//    uint32_t raw;
//    float volt;
//    raw = get_adc_value(ADC_CHANNEL_VREFINT);
//    volt = calib / raw ;
//    return volt;
//}


static int add_to_buffer(data_buffer_t* data, int16_t new)
{
    data->buf[data->idx] = new;
    data->idx ++;
    if(!data->is_full && data->idx == data->size)
        data->is_full = true;
    if(data->idx >= data->size)
        data->idx = 0;
    return 0;
}

static float compute_variance(data_buffer_t *data)
{
    float var = 0;
    float avg = 0;
    for(int i=0; i<data->size; i++)
        avg += data->buf[i];
    avg /= data->size;
    for(int i=0; i<data->size; i++)
    {
        float diff = data->buf[i] - avg;
        var += diff * diff;
    }
    var /= data->size - 1;
    var = sqrtf(var);
    return var;
}

// return drop event per min
static float compute_drop_event(data_buffer_t *data, float threshold, float samplerate)
{
    float diff = 0;
    float event = 0;
    for(int i=1; i<data->size; i++)
    {
        diff = fabs(data->buf[i] - data->buf[i-1]);
        if(diff > threshold)
            event ++;
    }
    event = event*60 / (data->size / samplerate);
    return event;
}

bool is_rain_print = false;
void thread_rain(void* parameters)
{
    sensor_config_t * cfg;
    rain_config_t * rain_cfg;
    uint16_t adc_raw[4] = {0};
    uint16_t rain_raw;
    uint16_t sys_vol_raw;
    float vdda;
    float calib = (float)VREFINT_CAL_VREF * (*VREFINT_CAL_ADDR) / 1000;

    rt_pin_mode(IR_LED_PIN, PIN_MODE_OUTPUT);
    rt_pin_write(IR_LED_PIN, GPIO_PIN_RESET);

    // wait until system cfg loaded
    // wait and load the configuration
    do{
        rt_thread_delay(100);
        cfg = get_sensor_config("Rain");
    }while(cfg == NULL && !is_system_cfg_valid());
    rain_cfg = cfg->user_data;

    // init the data
    int len = cfg->oversampling * 10 *cfg->data_period / 1000; // 10 second windows
    memset(&rain_data, 0, sizeof(data_buffer_t));
    rain_data.buf = malloc(len * sizeof(int16_t));
    rain_data.size = len;
    if(rain_data.buf == NULL){
        LOG_E("no memory for rain sensor data buffer, require %d bytes", len*sizeof(int16_t));
        return;
    }

//    MX_ADC1_Init();
//    HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED);
//    ADC_Init();
//    HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED);
//    HAL_ADC_Start_DMA(&hadc1, adc_raw, 4);

    // use LL to set up none interrupted DMA circular conversion.
    dma_ll_init(adc_raw, 4);
    adc_ll_init();
    adc_ll_start();
    rt_thread_delay(10);

    int period = cfg->data_period / cfg->oversampling;
    rt_tick_t last_t = rt_tick_get();
    int last_raw = adc_raw[1];//measure_rain();
    int16_t diff;
    float volt;
    while(1)
    {
        rt_thread_mdelay(period - rt_tick_get()%period);
        //printf("%d,%d,%d,%d\n", adc_raw[0],adc_raw[1],adc_raw[2],adc_raw[3] );

        // calculate the variance
        rt_tick_t t = rt_tick_get();
        // sample
        analog_power_request(true);
        rt_pin_write(IR_LED_PIN, GPIO_PIN_SET);
        rt_thread_mdelay(4);
        //HAL_ADC_Start_DMA(&hadc1, adc_raw, 4); // sample all adc
        rt_thread_mdelay(1);
        rain_raw = adc_raw[1];
        rt_pin_write(IR_LED_PIN, GPIO_PIN_RESET);
        analog_power_request(false);
        // calculate variance

        diff = rain_raw - last_raw;
        last_raw = rain_raw;
        rain.raw = rain_raw;
        add_to_buffer(&rain_data, diff); // variance of the change rate.
        if(rain_data.is_full && rt_tick_get() - last_t >= cfg->data_period)
        {
            last_t = rt_tick_get();
            rain.var = compute_variance(&rain_data);

            int level = 0;
            if(rain.var >= rain_cfg->light)
                level = 1;
            if(rain.var >= rain_cfg->moderate)
                level = 2;
            if(rain.var >= rain_cfg->heavy)
                level = 3;
            if(rain.var >= rain_cfg->violent)
                level = 4;
            rain.level = level;

            data_updated(&rain.info);
        }
        if(is_rain_print)
            printf("measurement:%d, diff: %d, rain_var: %f\n", rain_raw, diff, rain.var);

        // temporary place the system voltage sending here
        // since our ADC is not using RTT's framework, so not thread safe yet.
        uint16_t vdda_mv = __LL_ADC_CALC_VREFANALOG_VOLTAGE(adc_raw[2], LL_ADC_RESOLUTION_12B);
        uint16_t temp_degress = __LL_ADC_CALC_TEMPERATURE(vdda_mv, adc_raw[3], LL_ADC_RESOLUTION_12B);
        vdda = vdda_mv / 1000.f;
        //sys_vol_raw = measure_sys_voltage();
        sys_vol_raw = adc_raw[0];
        volt = sys_vol_raw / 4095.f * vdda * 2;
        sys.bat_voltage = volt * 0.1f + sys.bat_voltage * 0.9f; // simple RC filter.
        sys.sys_voltage = vdda;
        sys.mcu_temp = temp_degress;
        data_updated(&sys.info);
    }
}

int thread_rain_init()
{
    rt_thread_t tid;

    tid = rt_thread_create("rain", thread_rain, RT_NULL, 1024, 12, 1000); // the stack size cannot be too small.
    if(!tid)
        return RT_ERROR;
    rt_thread_startup(tid);
    return RT_EOK;
}
INIT_APP_EXPORT(thread_rain_init);

int rain_info(int argc, char* argv[])
{
    is_rain_print = !is_rain_print;
    return 0;
}
MSH_CMD_EXPORT(rain_info, print raw rain measurement to console)

void DMA1_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}



